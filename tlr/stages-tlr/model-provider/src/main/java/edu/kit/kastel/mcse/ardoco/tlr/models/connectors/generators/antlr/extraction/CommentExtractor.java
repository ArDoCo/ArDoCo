package edu.kit.kastel.mcse.ardoco.tlr.models.connectors.generators.antlr.extraction;

import java.util.ArrayList;
import java.util.List;

import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Token;

import edu.kit.kastel.mcse.ardoco.tlr.models.connectors.generators.antlr.elements.Comment;
import edu.kit.kastel.mcse.ardoco.tlr.models.connectors.generators.antlr.management.ElementStorageRegistry;

/**
 * Is responsible for extracting comments from an ANTLR token stream. The
 * comments validity is determined by the
 * implementing class. The extracted comments are then stored in a List of
 * Comment objects.
 */
public abstract class CommentExtractor {
    private final ElementStorageRegistry elementRegistry;
    private List<Comment> currentComments;

    protected CommentExtractor(ElementStorageRegistry elementRegistry) {
        this.elementRegistry = elementRegistry;
    }

    /**
     * Extracts comments from the given token stream and stores them in the elementRegistry
     * @param path, the path of the file as string
     * @param tokens, the token stream generated by the ANTLR parser
     */
    public void extract(String path, CommonTokenStream tokens) {
        List<Token> allTokens = tokens.getTokens();
        this.currentComments = new ArrayList<>();

        for (Token token : allTokens) {
            if (isComment(token)) {
                String text = token.getText().trim();
                if (isValidComment(text)) {
                    int startLine = token.getLine();
                    int endLine = token.getLine() + countCommentLines(text);
                    String cleansedText = cleanseComment(text);
                    Comment comment = createCommentElement(cleansedText, startLine, endLine, path);
                    this.currentComments.add(comment);
                }
            }
        }
        elementRegistry.addComments(currentComments);
    }


    public List<Comment> getCurrentComments() {
        List<Comment> copyOfComments = new ArrayList<>();
        for (Comment comment : currentComments) {
            copyOfComments.add(new Comment(comment.text(), comment.startLine(), comment.endLine(), comment.path()));
        }
        return copyOfComments;
    }

    /**
     * Determines if the given token is a comment
     * @param token, the token to check
     * @return true if the token is a comment, false otherwise
     */
    protected abstract boolean isComment(Token token);

    /**
     * Determines if the given text is a valid comment in the respective Programming Language
     * @param text, the text to check
     * @return true if the text is a valid comment, false otherwise
     */
    protected abstract boolean isValidComment(String text);

    /**
     * Cleanses the comment text from unwanted or unnecessary characters, e.g. comment delimiters
     * @param comment, the comment text to cleanse
     * @return the cleansed comment text
     */
    protected abstract String cleanseComment(String comment);

    private Comment createCommentElement(String text, int startLine, int endLine, String path) {
        return new Comment(text, startLine, endLine, path);
    }

    /**
     * Counts the number of lines in a given text
     * @param text, the text to count the lines of
     * @return the number of lines in the text, default is 0;
     */
    private int countCommentLines(String text) {
        int count = 0;
        for (int i = 0; i < text.length(); i++) {
            if (text.charAt(i) == '\n') {
                count++;
            }
        }
        return count;
    }

}
